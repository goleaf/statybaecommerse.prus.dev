---
description:
globs:
alwaysApply: true
---
# Cursor Rules: Auto-Test Generation for Laravel + Filament

## Trigger: When I change a PHP class under `app/**`
- Scope: Any saved edit to files matching `app/**/*.php`.
- Tasks the assistant must perform immediately:
  1. **Map class → test path**
     - If class namespace starts with `App\\Models\\`, create/update a **Unit** test under `tests/Unit/{RelativeNamespace}Test.php`.
     - If class is a controller, action, job, listener, service, query, Livewire/Filament component, or HTTP feature, create/update a **Feature** test under `tests/Feature/{RelativeNamespace}Test.php`.
     - Mirror subnamespaces; replace `App\` with `tests/Feature\` or `tests/Unit\` and append `Test`.
  2. **Detect Filament context**
     - If the class extends any Filament base (e.g. `Filament\Resources\Resource`, `Filament\Pages\Page`, `Filament\Widgets\Widget`, or Livewire components used by Filament), generate tests using Filament's testing patterns:
       - Use Pest (preferred) or PHPUnit consistently with the repo.
       - For pages/resources:
         - Assert routes mount (e.g., `get(Resource::getUrl('index'))->assertOk()`).
         - Assert policies/guards (auth + permissions).
         - For Tables: assert columns, filters, actions exist.
         - For Forms: assert schema fields and validation rules.
         - For actions: run form submit and assert DB changes/events.
       - For Widgets: assert render success and expected query/data.
       - For Livewire: use `Livewire::test(Component::class)` to set fields, call actions, and assert state/validation.
     - Use the MCP tool **filament-docs** to fetch exact API details or examples when unsure:
       - Prefer latest docs pages for Tables, Forms, Actions, Widgets, and Resources.
  3. **Test scaffolding & content rules**
     - If a matching test file **does not exist**, create it with:
       - Correct namespace (`Tests\Feature` or `Tests\Unit`).
       - `use` statements for Pest/PHUnit, Laravel helpers, Livewire, Filament, Models, Factories.
       - Boilerplate: database refresh/transactions as used by project.
       - At least 3–5 meaningful assertions per public behavior path.
     - If a matching test file **exists**, update it minimally:
       - Add/adjust cases that correspond to new/changed public methods, routes, validation, table columns, form fields, or events.
       - Keep style (Pest vs PHPUnit) consistent with existing file.
     - For Eloquent Models:
       - Assert fillable/guarded, casts, accessors/mutators, scopes.
       - Assert relationships with factories (`->for()`, `->has()`).
     - For Controllers/HTTP:
       - Route status, redirects, auth gates, validation errors, DB assertions, events/notifications/queues.
  4. **Run tests automatically**
     - Open an integrated terminal and run:  
       - If repo uses Pest: `php artisan test` (Pest auto-detected).  
       - Else: `php artisan test`.
     - If failures occur:
       - Read the top 20 lines of each failure.
       - Attempt a single corrective pass in the test **or** the changed class if the failure is clearly test drift (typos, wrong route names, missing import, outdated assertion).
       - Re-run the suite.
  5. **Output / Notes**
     - Post a brief summary with changed/created test file paths and a one-line rationale for each.
     - If Filament docs were consulted, include the doc titles and anchors used (no raw links required unless I ask).

## Conventions
- Use environment helpers:
  - Authentication: `actingAs(User::factory()->create())`.
  - Database: `RefreshDatabase` (or project's chosen trait).
  - Livewire: `use Livewire\Livewire;`
- For Filament Table tests, prefer structure checks like:
  - `expect($table->getColumns())->sequence(fn ($col) => $col->getName() === 'name', ...)`
- For Forms, verify **required/unique** rules and typical edge cases.
- Keep each test atomic and descriptive (`it('lists records with filters')`).
